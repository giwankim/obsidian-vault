---
title: "in, out, reified: A Practical Guide to Kotlin Generics"
source: "https://proandroiddev.com/in-out-reified-a-practical-guide-to-kotlin-generics-2beb6b9eb67a"
author:
  - "[[Anshul Vyas]]"
published: 2026-01-13
created: 2026-01-26
description: "in, out, reified: A Practical Guide to Kotlin Generics Building a simple event bus to understand variance, once and for all Introduction Kotlin’s standard library is full of generic signatures — …"
tags:
  - "clippings"
---
[Sitemap](https://proandroiddev.com/sitemap/sitemap.xml)

Get unlimited access to the best of Medium for less than $1/week.[Become a member](https://medium.com/plans?source=upgrade_membership---post_top_nav_upsell-----------------------------------------)

[

Become a member

](https://medium.com/plans?source=upgrade_membership---post_top_nav_upsell-----------------------------------------)## [ProAndroidDev](https://proandroiddev.com/?source=post_page---publication_nav-c72404660798-2beb6b9eb67a---------------------------------------)

[![ProAndroidDev](https://miro.medium.com/v2/resize:fill:76:76/1*qc2BOr4xE7A0QV8N5w4fow.png)](https://proandroiddev.com/?source=post_page---post_publication_sidebar-c72404660798-2beb6b9eb67a---------------------------------------)

The latest posts from Android Professionals and Google Developer Experts.

## Introduction

Kotlin’s standard library is full of generic signatures — `List<out E>`, `Comparable<in T>`, `Sequence<out T>`. The `in` and `out` keywords appear constantly, but what do they actually mean? And when does a regular type parameter need one of these modifiers?

Even though generics are common in Kotlin, some of its underlying mechanics might seem fuzzy without a deeper understanding of Kotlin’s [variance system](https://kotlinlang.org/docs/generics.html), which is covered in this post.

This post builds a simple event bus from scratch. The example covers all three variance types (invariant, covariant, and contravariant) in a way that maps directly to real-world usage. The complete code is available on [GitHub Gist](https://gist.github.com/anshu7vyas/4f3735340bca7cb9c6f7a151dcfa069f) and [Kotlin Playground](https://pl.kotl.in/yhaMzy_If) if you prefer to dive straight in.

## The mental model

Before diving into code, it helps to establish what variance actually controls: the direction of type substitution.

- `**out T**` **(Covariance):** The class only produces `T`, never consumes it. This makes it safe to substitute a subtype. A function returning `List<out Animal>` can return a `List<Dog>` because reading a Dog as an Animal works fine. The direction flows from specific to general: **subtype → supertype**.
- `**in T**` **(Contravariance):** The class only consumes `T`, never produces it. This makes it safe to substitute a supertype. A function accepting `Comparable<in String>` can accept `Comparable<Any>` because a comparator that handles any object can certainly handle strings. The direction flows from general to specific: **supertype → subtype**.
- `**T**` **(Invariant):** The class both produces and consumes `T`. No substitution is safe in either direction. `MutableList<T>` is invariant because you both read from and write to it.
![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*eFamD7yIwexlnkaCedK1MA.png)

Image generated by Google Gemini

The compiler enforces these constraints to prevent runtime `ClassCastException` errors. Java developers might recognize this pattern as PECS (Producer Extends, Consumer Super), a mnemonic introduced by Joshua Bloch in [Effective Java](https://www.oreilly.com/library/view/effective-java/9780134686097/) (Item 31). Kotlin's `in` and `out` keywords make the same concept explicit and readable.

## Why EventBus

An event bus is a familiar pattern for most developers. At its core, it allows publishers to send events and subscribers to receive them. This natural separation of producers and consumers makes it an ideal example for exploring variance.

> The implementation in this post is intentionally minimal: single-threaded, no external dependencies, pure Kotlin `stdlib`. Unlike production event buses that typically handle multiple event types through a heterogeneous map, this example uses a single-type `EventBus<T>` to keep the focus on variance.

Each operation maps to a different variance type: the bus itself is invariant, subscribing demonstrates covariance, and publishing demonstrates contravariance.

## Building the bus

Let’s build the event bus piece by piece, examining how each component uses variance differently.

**Step 1: The Invariant Start**

We start with a simple container. We need to store subscribers and invoke them.

```c
class EventBus<T> {
    // Invariant: MutableMap both stores and retrieves, locking T to an exact type
    private val subscribers = mutableMapOf<String, (T) -> Unit>()
}
```

Because `MutableMap` both reads and writes `T`, the type parameter must remain invariant. You cannot cast `EventBus<Dog>` to `EventBus<Animal>` here.

**Step 2: Defining Output and Input**

This is where covariance (`out`) and contravariance (`in`) come into play. To get more flexibility, we separate the “Producer” and “Consumer” roles into interfaces. This lets us take advantage of variance when passing subscriptions and consumers around.

 [![Become a member](https://miro.medium.com/v2/da:true/resize:fit:0/60026f4340686a391639ac58864da18070aa773cea45de6e55fa47fd56bfdb74) ![Become a member](https://miro.medium.com/v2/da:true/resize:fit:0/c061bd6cb52734164bf0c66f2543a6bc2acbe24ae3985dc15c898b3ddb2e1940)](https://medium.com/plans?source=upgrade_membership---post_li_non_moc_upsell--2beb6b9eb67a---------------------------------------)

First, the **Subscription**. This only provides information (like the event type) or actions (unsubscribe). It never takes a `T` in. It is a pure **Producer**.

```c
interface Subscription<out T> {
    val eventType: Class<T>
    fun unsubscribe()
}
```

Second, the **Consumer**. This interface only ever accepts an event. It never returns one. It is a pure **Consumer**.

```c
interface EventConsumer<in T> {
    fun onEvent(event: T)
}
```

**Step 3: Putting It Together**

Now we refactor our `EventBus` to use these interfaces. This unlocks the variance capabilities we defined above.

```c
class EventBus<T>(private val eventType: Class<T>) {
    // Now using our variance-aware interfaces instead of raw lambdas
    private val subscribers = mutableMapOf<String, EventConsumer<T>>()

    fun subscribe(consumer: EventConsumer<T>): Subscription<T> {
        val id = UUID.randomUUID().toString()
        subscribers[id] = consumer
        
        return object : Subscription<T> {
            override val eventType: Class<T> = this@EventBus.eventType
            override fun unsubscribe() {
                subscribers.remove(id)
            }
        }
    }
    
    fun publish(event: T) {
        subscribers.values.forEach { it.onEvent(event) }
    }
}
```

We now have three variance types working in unison:

- `EventBus<T>` is invariant (stores and invokes)
- `Subscription<out T>` is covariant (only produces)
- `EventConsumer<in T>` is contravariant (only consumes)

## The reified unlock

Generic type parameters are erased at runtime (Type Erasure). This means you normally can’t check `T::class` inside a generic class.

In our `EventBus` constructor above, we had to pass `eventType: Class<T>`. Kotlin's `reified` keyword solves this, but it only works in `inline` functions.

We can create a helper function to create a bus without manually passing the class:

```c
// inline allows us to "reify" (keep) the type T at runtime
inline fun <reified T : Any> createEventBus(): EventBus<T> {
    println("Creating bus for: ${T::class.simpleName}")
    return EventBus(T::class.java)
}

// Usage: No need to write (String::class.java)
val stringBus = createEventBus<String>()
```

This pattern appears throughout the Kotlin ecosystem, from Android’s `startActivity<T>()` to Koin's `get<T>()`. Any API that needs runtime access to a generic type benefits from `reified`.

## Star projection

Sometimes the specific type parameter doesn’t matter. Kotlin provides **star projection** `<*>` for these cases.

Imagine an Android ViewModel holding a list of subscriptions to various different buses. You want to unsubscribe from all of them when the screen closes. You don’t care if the subscription is for `UserEvent` or `NetworkEvent`, you just want to call `unsubscribe()`.

```c
// We can mix Subscription<String>, Subscription<Int>, etc.
val allSubs = mutableListOf<Subscription<*>>()

fun clearAll() {
    // Safe: unsubscribe() takes no arguments
    allSubs.forEach { it.unsubscribe() } 
}
```

`Subscription<*>` means *"a Subscription of some type, but I don't know or care which."*

The tradeoff: you can read from a star-projected type (as `Any?`), but you **cannot safely write** to it (because the compiler doesn't know what type it expects).

> Star projection trades type specificity for flexibility.

## Summary

The one rule: if you only output `T`, use `out`. If you only input `T`, use `in`. If you do both, leave it alone.

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*_CRsAWegt7QdM75sc1VN1Q.png)

> The complete EventBus implementation is available as a [GitHub Gist](https://gist.github.com/anshu7vyas/4f3735340bca7cb9c6f7a151dcfa069f) or try it directly in the [Kotlin Playground](https://pl.kotl.in/yhaMzy_If).

Understanding these concepts makes consuming APIs easier, compiler errors less mysterious, and opens the door to writing more flexible code.

[![ProAndroidDev](https://miro.medium.com/v2/resize:fill:96:96/1*qc2BOr4xE7A0QV8N5w4fow.png)](https://proandroiddev.com/?source=post_page---post_publication_info--2beb6b9eb67a---------------------------------------)

[![ProAndroidDev](https://miro.medium.com/v2/resize:fill:128:128/1*qc2BOr4xE7A0QV8N5w4fow.png)](https://proandroiddev.com/?source=post_page---post_publication_info--2beb6b9eb67a---------------------------------------)

[Last published 12 hours ago](https://proandroiddev.com/building-a-video-feed-in-jetpack-compose-a-media3-tutorial-5d8f6955600f?source=post_page---post_publication_info--2beb6b9eb67a---------------------------------------)

The latest posts from Android Professionals and Google Developer Experts.

Staff Software Engineer at Turo

## More from Anshul Vyas and ProAndroidDev

## Recommended from Medium

[

See more recommendations

](https://medium.com/?source=post_page---read_next_recirc--2beb6b9eb67a---------------------------------------)